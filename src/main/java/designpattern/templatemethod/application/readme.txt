说到模板方法模式，我们JDK当中有一个类与它还有一个不得不说的故事，那就是类加载器。

JDK类加载器可以大致分为三类，分别是启动类加载器，扩展类加载器，以及应用程序加载器。

这三者加载类的路径分别为如下：

启动类加载器：JAVA_HOME/lib目录下，以及被-Xbootcalsspath参数设定的路径，不过启动类加载器加载的类是有限制的，如果JVM不认识的话，你放
在这些目录下也没用。

扩展类加载器：JAVA_HOME/lib/ext目录下，以及被java.ext.dirs系统变量指定的路径。

应用程序类加载器：用户自己的类路径（classpath），这个类加载器就是我们经常使用的系统类加载器，并且JDK中的抽象类ClassLoader的默认父类加载
器就是它。

在这里为什么说类加载器和模板方法模式有关呢，是因为ClassLoader类就使用了模板模式，去保证类加载过程中的唯一性。LZ先给各位看下这个类当中的
模板模式的应用。

见ClassLoader中的源码：
LZ截取了主要的部分，为了突出这三个方法。在上面LZ加了简单的注释，相信经过刚才的介绍，各位应该能看出来这是一个模板方法模式，只是它没有定义
抽象方法，因为findClass这个方法，并不是必须实现的，所以JDK选择留给程序员们自己选择是否要覆盖。

从代码上我们可以看出，在ClassLoader中定义的算法顺序是。

1，首先看是否有已经加载好的类。

2，如果父类加载器不为空，则首先从父类类加载器加载。

3，如果父类加载器为空，则尝试从启动加载器加载。

4，如果两者都失败，才尝试从findClass方法加载。

这是JDK类加载器的双亲委派模型，即先从父类加载器加载，直到继承体系的顶层，否则才会采用当前的类加载器加载。这样做的目的刚才已经说了，是为了
JVM中类的一致性。

如果有读者第一次接触这方面的知识，估计会比较迷茫，下面LZ给出一个例子。各位猜测下下面程序的运行结果会是什么？

相信各位都可以毫无疑问的猜测出来，结果应该是true，这是因为entity是ClassLoaderTest类的一个实例，instanceof关键字用来判断一个实例是否
属于一个特定的类型，所以结果就是true。

那么各位再来猜猜下面这段代码的运行结果会是什么？

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

对于类加载器比较熟悉的读者们可能觉得这个结果并不出乎意料，可是或许还是有人会比较意外，为什么结果会是false呢？

这是因为如果没有按照ClassLoader中提供的骨架算法去加载类的话，可能会造成JVM中有两个一模一样的类信息，他们是来自一个类文件，但却不是一个
加载器加载的，所以这两个类不相等。

不过你可能会想，既然如此，为何不把loadClass方法写成final类型的，这样不是更安全吗？

这是因为有的时候我们希望JVM当中每一个类有且仅有一个，但有的时候我们希望有两个，甚至N个，就比如我们的tomcat，你可以想象下，你每一个项目
假设都有com.xxx.xxxx.BaseDao等等，如果这些类都是一个的话，你的tomcat还能同时启动多个WEB服务吗？虽说tomcat也是遵循的双亲委派模型，
但是从此也可以看出来，我们并不是在所有时候都希望同一个全限定名的类在整个JVM里面只有一个。

这里提到类加载器，是为了给模板方法一个现有的现实中的例子，以便于有些看多了自己制造的例子的读者可以换个口味，如果有机会，LZ会在这个系列
完结以后，专门开一个系列来和各位分享学习虚拟机过程中的感悟，本次不再过多介绍类加载器的相关内容。

另外，如果多掌握一些类加载器的知识，还是对平时的工作和学习有很大帮助的，各位也可以私下去搜索下相关资料。

好了，模板方法模式就介绍到这里吧，希望各位都有自己的收获。

这也是类加载器为何要使用模板模式给我们定义好查找的算法，是为了保证我们加载的每一个类在虚拟机当中都有且仅有一个。

