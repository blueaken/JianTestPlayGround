java_my_life博客
http://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html

============
设计原则：遵循迪米特、开闭原则
常用场景：需要将观察者与被观察者解耦或者是观察者的种类不确定
使用概率：40%
复杂度：中
变化点：观察者的种类与个数
选择关键点：观察者与被观察者是否是多对一的关系
逆鳞：观察者之间有过多的细节依赖
============


一个软件系统里面包含了各种对象，就像一片欣欣向荣的森林充满了各种生物一样。在一片森林中，各种生物彼此依赖和约束，形成一个个生物链。一种生物
的状态变化会造成其他一些生物的相应行动，每一个生物都处于别的生物的互动之中。

同样，一个软件系统常常要求在某一个对象的状态发生变化的时候，某些其他的对象做出相应的改变。做到这一点的设计方案有很多，但是为了使系统能够易
于复用，应该选择低耦合度的设计方案。减少对象之间的耦合有利于系统的复用，但是同时设计师需要使这些低耦合度的对象之间能够维持行动的协调一致，
保证高度的协作。观察者模式是满足这一要求的各种设计方案中最重要的一种。

观察者模式所涉及的角色有：

　　●　　抽象主题(Subject)角色：抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观
        察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。

　　●　　具体主题(ConcreteSubject)角色：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题
        角色又叫做具体被观察者(Concrete Observable)角色。

　　●　　抽象观察者(Observer)角色：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。

　　●　　具体观察者(ConcreteObserver)角色：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状
        态与主题的状态 像协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。

推模型和拉模型

　　在观察者模式中，又分为推模型和拉模型两种方式。

　　●　　推模型

　　　　 主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。

　　●　　拉模型

　　　　 主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中
        拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用
        来获取了。

        拉模型通常都是把主题对象当做参数传递。

Tomca中多次使用了观察者模式，比如控制组件生命周期LifeCycle类，还有Servlet实例的创建、Session的管理、Container等都是同样的原理。

=========================
左潇龙：
http://www.cnblogs.com/zuoxiaolong/p/pattern7.html

观察者模式和事件驱动可以达到的效果一模一样，那么两者是不是一样呢？

答案当然是否定的，首先我们从实现方式上就能看出，事件驱动可以解决观察者模式的问题，但反过来则不一定，另外二者所表达的业务场景也不一样，比如
上述例子，使用观察者模式更贴近业务场景的描述，而使用事件驱动，从业务上讲，则有点勉强。

二者除了业务场景的区别以外，在功能上主要有以下区别。

1，观察者模式中观察者的响应理论上讲针对特定的被观察者是唯一的（说理论上唯一的原因是，如果你愿意，你完全可以在update方法里添加一系列的
elseif去产生不同的响应，但LZ早就说过，你应该忘掉elseif），而事件驱动则不是，因为我们可以定义自己感兴趣的事情，比如刚才，我们可以监听
作者发布新书，我们还可以在监听器接口中定义其它的行为。再比如tomcat中，我们可以监听servletcontext的init动作，也可以监听它的destroy动作。

2，虽然事件驱动模型更加灵活，但也是付出了系统的复杂性作为代价的，因为我们要为每一个事件源定制一个监听器以及事件，这会增加系统的负担，
各位看看tomcat中有多少个监听器和事件类就知道了。

3，另外观察者模式要求被观察者继承Observable类，这就意味着如果被观察者原来有父类的话，就需要自己实现被观察者的功能，当然，这一尴尬事情，
我们可以使用适配器模式弥补，但也不可避免的造成了观察者模式的局限性。事件驱动中事件源则不需要，因为事件源所维护的监听器列表是给自己定制的，
所以无法去制作一个通用的父类去完成这个工作。

4，被观察者传送给观察者的信息是模糊的，比如update中第二个参数，类型是Object，这需要观察者和被观察者之间有约定才可以使用这个参数。而在
事件驱动模型中，这些信息是被封装在Event当中的，可以更清楚的告诉监听器，每个信息都是代表的什么。

由于上述使用事件驱动有点勉强，所以LZ给各位模拟一个我们js当中的一个事件驱动模型，就是按钮的点击事件。

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

观察者模式所欠缺的是设计上的问题，即观察者和被观察者是多对一的关系，那么反过来的话，就无法支持了。

各位可以尝试将二者位置互换达到这个效果，这算是设计模式的活用。（Push Vs Pull）很简单，就是让被观察者做成一个接口，提供是否改变的方法，
让观察者维护一个被观察者的列表，另外开启一个线程去不断的测试各个被观察者是否改变。由于本篇已经够长，所以LZ不再详细编写，如果有哪位读者有
需要，可以在下方留言，LZ看到的话，如果有时间，会写出来放到资源里供各位下载。

观察者模式还有一个缺点就是，每一个观察者都要实现观察者接口，才能添加到被观察者的列表当中，假设一个观察者已经存在，而且我们无法改变其代码，
那么就无法让它成为一个观察者了，不过这个我们依然可以使用适配器模式解决。但是还有一个问题就不好解决了，就是假如我们很多类都是现成的，当被
观察者发生变化时，每一个观察者都需要调用不同的方法，那么观察者模式就有点捉襟见肘的感觉了，我们必须适配每一个类去统一他们变化的方法名称为
update，这是一个很可怕的事情。

对于事件驱动就没有这样的问题，我们可以实现多个监听器来达到监听多个事件源的目的，但是它的缺点刚才已经说过了，在事件源或者事件增加时，监听器
和事件类通常情况下会成对增加，造成系统的复杂性增加，不过目前看来，事件驱动模型一般都比较稳定，所以这个问题并不太明显，因为很少见到无限增加
事件的情况发生。

还有一个缺点就是我们的事件源需要看准时机触发自己的各个监听器，这也从某种意义上增加了事件源的负担，造成了类一定程度上的臃肿。

最后，LZ再总结下二者针对的业务场景概述。

观察者模式：发布（release）--订阅（subscibe），变化（change）--更新（update）

事件驱动模型：请求（request）--响应（response），事件发生（occur）--事件处理（handle）

＝＝＝
问题：
潇龙提出JDK提供的Observable类的notifyObservers没有catch update 可能会出现的异常：

被观察者除了一点同步的地方需要特殊解释一下，其余的相信各位都能看明白各个方法的用途。其实上述JDK的类是有漏洞的，或者说，在我们使用观察者
模式时要注意一个问题，就是notifyObservers这个方法中的这一段代码。

for (int i = arrLocal.length-1; i>=0; i--)
            ((Observer)arrLocal[i]).update(this, arg);
在循环遍历观察者让观察者做出响应时，JDK没有去抓取update方法中的异常，所以假设在这过程中有一个update方法抛出了异常，那么剩下还未通知的
观察者就全都通知不到了，所以LZ个人比较疑惑这样的用意（LZ无法想象JAVA类库的制造者没考虑到这个问题），是sun当时真的忘了考虑这一点，还是
另有它意？当然各位读者如果有自己的见解可以告知LZ，不过LZ认为，不管是sun如此做是别有用意，还是真的欠考虑，我们都要注意在update方法里一定
要处理好异常，个人觉得JDK中比较保险的做法还是如下这样。

for (int i = arrLocal.length-1; i>=0; i--){
            try {
                ((Observer)arrLocal[i]).update(this, arg);
            } catch (Throwable e) {e.printStackTrace();}
        }
这样无论其中任何一个update是否成功都不会影响其余的观察者进行更新状态，我们自己比较保险的做法就是给update方法整个加上try块，或者确认不会
发生运行时异常。
