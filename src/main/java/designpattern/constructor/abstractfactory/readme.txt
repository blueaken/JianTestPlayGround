http://www.cnblogs.com/zuoxiaolong/p/pattern6.html

设计原则：遵循单一职责、依赖倒置、开闭原则
常用场景：需要一个接口可以提供一个产品族，且不必知道产品的具体种类
使用概率：30%
复杂度：中
变化点：工厂与产品的种类
选择关键点：产品族是否需要一起提供，且是否有一致的接口
逆鳞：无
相关设计模式
建造者模式：两者都是建造一批对象或者说产品，不同的是两者的目的和实现手段，在建造者模式中，是为了复用对象的构建过程而定义了一个指挥者，而
在抽象工厂模式中，是为了提供一个这批对象的创建接口而定义了抽象工厂接口。


concept里的代码比较简单，结构很清晰但不太容易理解，因为它全部是抽象的表示，与实际联系不上，所以也会对各位的理解造成阻碍，下面我们就一起
讨论一个现有的例子，去加深去抽象工厂模式的理解。

======

有关工厂的三个模式到这里就全部介绍完了，三者有着很大的关联和明显的关系，要想灵活运用这三种设计模式，还是要彻底理解它们所针对的问题以及三者
的关系。下面罗列下这三种设计模式依次进化的原因。

                  1，首先从简单工厂进化到工厂方法，是因为工厂方法弥补了简单工厂对修改开放的弊端，即简单工厂违背了开闭原则。

                  2，从工厂方法进化到抽象工厂，是因为抽象工厂弥补了工厂方法只能创造一个系列的产品的弊端。

各位可以思考下，假设我们不使用抽象工厂模式，改用工厂方法去处理抽象工厂中多产品的问题，如何处理呢？

我们在处理很多问题的时候其实是有很多种方式的，而且每一种方式可能都有各自的好处和坏处，很难去判断说那一种方式是最好的，而且也根本就没有这个
说法，所以我们能做的，就是根据实际的情况去掂量各个方式的利弊，从而选择出一种更适合当前情况的处理方式。

本期抽象工厂模式就到这里了，希望各位看到这里对三个与工厂相关的模式有一定自己的理解，并且可以灵活使用，达到无模式就是最好的模式的境界，甚至，
我们可以把我们自己写的东西起个名字，冒充设计模式，比如最后一种我们叫它组合工厂模式。当然，LZ本人并未达到无模式的境界，正在与各位一起努力。


