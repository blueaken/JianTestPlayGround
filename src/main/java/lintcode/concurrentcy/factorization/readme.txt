https://laixiaoxing.blog.csdn.net/article/details/82847839
参考这个帖子练习一下，以前也用过CountDownLatch

1.因数分解

因数分解是对一个数字m,找出它所有的因数的过程，比如说数字6 因数分解之后为 2x3

2.为何选择因数分解

因为因数分解是一个很费事的计算过程，目前没有很好的算法可以提高效率，可以很好的用来模拟复杂计算处理过程，以便于我们明显的去观察在不同的情况下线程的状态

3. 因数分解的算法代码如下

具体就是先从2开始除，看2能不能被整除，如果可以则继续除以2，如果不能，则除以3 以此类推，直到除数不在小于m

======================
Step 1.

FactorsService_SingleThread 首先使用单线程方法

那么有什么更好的方法可以提升速度吗？答案是从算法来说其实是没有的，大数的因数分解很难做，因此奠定了非对称加密的基石（非对称加密的秘钥生成
利用是利用到了这点特性，已知积很难算出因数，但是已知因数却很容易算出积） 算法考虑优化不是我们现在这个博文的主题，接下来进入正题，我们使
用多线程解决

=======================

通俗的来说线程是比进程更轻量级的调度单元，一个进程里面可以包含多个线程。
举个例子，我们常说的八核cpu 指定的就是1个cpu有8个物理处理单元，也就是最多可以同时跑8个物理线程。 （cpu还有超线程技术，可以用一个物理线程模拟多个线程）
既然cpu如此强大，但是如果我们的程序是单线程的，那么cpu的强大功能就浪费了，单线程用不上多核。
疑问1:我们用单线程做了两个因数分解，耗时10073毫秒，那么我们起两个线程，同时做这个因数分解的任务，那是不是只需要一半的时间?
4706/2206 大概2倍差距，确实节省一半的时间

疑问2:如果我有5个数要做因数分解，那我起五个线程，是不是也可以缩小5倍时间？
答案是不能
9945/4589 大概就是2倍的差距，并没有5倍

因此提升线程并不是线性的提升效率，反而随着线程数量的增加，cpu会花费大量的时间用于处理各个线程之间的切换上

切换时候需要保存各个线程的状态，又要恢复，而且各个线程之间彼此还会竞争cpu

合理的线程数目约为N 或者N+1 N为cpu核心数

